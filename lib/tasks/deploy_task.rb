require 'component'
require 'consumable'
require 'runner'
require 'util/archive'

require_relative 'base_task'
require_relative 'teardown_task'

require "#{BASE_DIR}/lib/errors/pipeline_error"
require "#{BASE_DIR}/lib/errors/pipeline_aggregate_error"

include Qantas::Pipeline::Errors
include Util::Archive

class DeployTask < BaseTask
  @context_task
  @teardown_task

  def name
    "deploy"
  end

  def check_state
    context_task.read

    if ["start"].include? Context.pipeline.state
      Log.debug "Build is currently in state #{Context.pipeline.state.inspect}. Proceeding with deployment."
    else
      raise "Cannot perform deployment from current state #{Context.pipeline.state.inspect}"
    end
  end

  def check_service_now
    context_task.read
    ServiceNow.request_deploy
  end

  def load_components
    context_task.read

    Context.component.set_variables("pipeline", {
      "PlanKey" => Defaults.sections[:plan_key],
      "Ams" => Defaults.sections[:ams],
      "Qda" => Defaults.sections[:qda],
      "As" => Defaults.sections[:as],
      "Ase" => Defaults.sections[:ase],
      "Branch" => Defaults.sections[:branch],
      "Build" => Defaults.sections[:build],
      "DeploymentEnv" => Defaults.sections[:env],
    })

    # Load and parse all of the components
    Log.info "Loading components"
    begin
      payload_dir = File.join(File.expand_path("..", Dir.pwd), "payload")
      FileUtils.mkdir_p payload_dir

      artefact_bucket = Context.s3.artefact_bucket_name
      ci_artefact_path = Defaults.ci_artefact_path

      raise "artefact_bucket is nil!" if artefact_bucket.nil?
      raise "ci_artefact_path is nil!" if ci_artefact_path.nil?

      # Download the components tarball from the CI artefacts bucket
      Log.info "Retrieving component definitions from CI artefacts bucket"
      local_filename = File.join(File.expand_path("..", Dir.pwd), "payload", "components.tar.gz")

      response = AwsHelper.s3_download_object(
        bucket: artefact_bucket,
        key: "#{ci_artefact_path}/components.tar.gz",
        local_filename: local_filename
      )

      ci_plan_key = response.metadata['bamboo_plankey']
      ci_build = response.metadata['bamboo_buildnumber']

      Context.component.set_variables("pipeline", {
        "CI_PlanKey" => ci_plan_key,
        "CI_Build" => ci_build
      })

      Log.output "Deploying components and artefacts generated by " \
          "#{ci_plan_key} - #{ci_build}"

      # Extract the tarball
      untar! gunzip!(local_filename), payload_dir

      # Load all component definitions
      components = Component.load_all(payload_dir, Defaults.sections[:ase].upcase, Defaults.sections[:branch])
      Context.pipeline.set_variables({ 'components' => components })
      @components = Consumable.instantiate_all(components)
    rescue => e
      raise "Failed to load all components - #{e}"
    ensure
      FileUtils.rm_rf File.join Dir.pwd, 'payload'
    end
  end

  def copy_artefacts
    context_task.read

    # Copy all component artefacts from CI to CD bucket
    artefact_bucket = Context.s3.artefact_bucket_name

    begin
      @components.keys.each do |name|
        ci_artefact_path = Defaults.ci_artefact_path(component_name: name)
        cd_artefact_path = Defaults.cd_artefact_path(component_name: name)

        AwsHelper.s3_copy_object(
          artefact_bucket,
          "#{ci_artefact_path}/app.tar.gz",
          artefact_bucket,
          "#{cd_artefact_path}/app.tar.gz"
        )

        # if codedeploy component, expect revision package under the followint paths:
        # linux   - /s3/pipeline/CI/……/branch/latest/component_name_codedeploy_revision.tar.gz
        # windows - /s3/pipeline/CI/……/branch/latest/component_name_codedeploy_revision.zip

        if @components[name].class.to_s == "AwsCodeDeploy"

          target_component_name = @components[name].get_target_component_name

          Log.output "Target name: #{target_component_name}"

          comsumable_definitions = Consumable.get_consumable_definitions
          target_definition = comsumable_definitions[target_component_name]
          is_windows_component = Defaults.codedeploy_win_component?(definition: target_definition)

          revision_file_extension = "tar.gz"

          if is_windows_component
            revision_file_extension = "zip"
          end

          sections = Defaults.sections

          revision_ci_artefact_path = Defaults.ci_artefact_path(component_name: [
            target_component_name,
            "revision.#{revision_file_extension}"
          ].join('/'))

          revision_cd_artefact_path = Defaults.cd_common_artefact_path(component_name: [
            'codedeploy',
            sections[:build],
            target_component_name,
            "revision.#{revision_file_extension}"
          ].join('/'))

          Log.output "Copying revision for component #{name}"
          Log.output "  - src: #{revision_ci_artefact_path}"
          Log.output "  - dst: #{revision_cd_artefact_path}"

          AwsHelper.s3_copy_object(
            artefact_bucket,
            revision_ci_artefact_path,
            artefact_bucket,
            revision_cd_artefact_path
          )
        end
      end
    rescue => e
      raise "Failed to copy build artefacts to deployment bucket - #{e}"
    end
  end

  def print_resource_group
    # Output the AWS Resource Group URL for this application service branch
    Log.output "AWS Resource Group (You must first log into the AWS Console" \
    " and switch roles into the correct account): #{Defaults.resource_group_url}"
  end

  def kms
    context_task.read
    Runner.deploy_kms
  end

  def load_persistence
    load_components
    Runner.load_persistence(@components)
  end

  def security
    load_components
    Runner.deploy_security_items(@components)
  end

  def pre_deploy_actions
    if Context.environment.variable('skip_actions', 'false') == 'true'
      Log.snow "WARNING: Skipping actions execution"
      Log.warn "WARNING: Skipping actions execution"
    else
      # Run actions
      successful, failed = Runner.run_actions(@components, 'PreDeploy')

      if failed.any?
        failed_actions = failed.map(&:name)
        Log.snow "ERROR: Failed to run user defined actions: #{failed_actions.inspect}"
        raise "Failed to run user defined actions: #{failed_actions.inspect}"
      end
    end
  end

  def components
    load_components

    Log.snow "Starting deployment for plan #{Defaults.sections[:plan_key].upcase.inspect}."
    Log.snow "Detailed results are available from Bamboo (#{ENV['bamboo_resultsUrl']})."

    # Deploy the components
    successful, failed, extented_failed_state = Runner.deploy(@components)

    # Save results into the context
    Context.pipeline.set_variables({
      'deploy_successful_consumables' => successful.map(&:definition),
      'deploy_failed_consumables' => failed.map(&:definition)
    })

    if failed.any?
      failed_components = failed.map(&:component_name)
      Log.snow "ERROR: Failed to deploy components: #{failed_components.inspect}"

      raise _get_aggregate_failed_component_error(
        "Failed to deploy components: #{failed_components.inspect}",
        extented_failed_state
      )
    end
  end

  def post_deploy_actions
    if Context.environment.variable('skip_actions', 'false') == 'true'
      Log.snow "WARNING: Skipping actions execution"
      Log.warn "WARNING: Skipping actions execution"
    else

      # Run actions
      successful, failed = Runner.run_actions(@components, 'PostDeploy')

      if failed.any?
        failed_actions = failed.map(&:name)
        Log.snow "ERROR: Failed to run user defined actions: #{failed_actions.inspect}"
        raise "Failed to run user defined actions: #{failed_actions.inspect}"
      end
    end
  end

  def deploy
    Defaults.set_pipeline_task('deploy')
    task_exception = nil

    check_state
    check_service_now

    begin
      load_components

      # report to Splunk
      # call after deploy:load_components, we need env vars AND components stat set
      begin
        stage_stats = StatHelper.start_pipeline_stage(
          context: Context,
          stage_name: 'deploy'
        )
        Log.splunk_http(stage_stats)
      rescue => e
        Log.warn "Failed to report to Splunk - #{e} - #{e.backtrace}"
      end

      copy_artefacts
      print_resource_group
      kms
      load_persistence
      security
      pre_deploy_actions
      components
      post_deploy_actions

      Context.pipeline.state = "deployed"
      ServiceNow.done_success
    rescue => e
      task_exception = e

      Log.error "deploy has failed - #{e}"
      Log.error get_error_report(e)

      Context.pipeline.state = "deploy_failed"
      ServiceNow.done_failure

      if Defaults.is_codedeploy_deployment_mode?
        Log.error "CodeDeploy provision mode is detected. Skipping clean up after deploy"
      else
        # Clean up partial deployment
        if !_cleanup_after_deploy_failure?
          Log.error "Skipping cleanup (#{_deploy_failure_cleanup_flag_name} is set to false)"
        else
          Log.error "Cleaning up partial deployment (#{_deploy_failure_cleanup_flag_name} is set to true)"
          begin
            teardown_task.components
          rescue => e
            Log.error "Failed to perform cleanup - #{e}"
          end
        end
      end

      raise e
    ensure
      # Save the context
      begin
          Log.info "Saving current context"

          context_task.write
      rescue => e
        Log.error "Failed to save the context - #{e}"
        end

      # report to Splunk
      begin
        exception_stats = StatHelper.exceptions_stats(task_exception)

        stage_stats = StatHelper.finish_pipeline_stage(
          context: Context,
          stage_name: 'deploy',
          additional_hash: exception_stats
        )

        Log.splunk_http(stage_stats)
      rescue => e
        Log.warn "Failed to report to Splunk - #{e} - #{e.backtrace}"
      end
    end
  end

  def context_task
    if @context_task.nil?
      @context_task = ContextTask.new
    end

    @context_task
  end

  def teardown_task
    if @teardown_task.nil?
      @teardown_task = TeardownTask.new
    end

    @teardown_task
  end

  private

  def _deploy_failure_cleanup_flag_name
    'bamboo_cleanup_after_deploy_failure'
  end

  def _cleanup_after_deploy_failure?
    cleanup_value = _env[_deploy_failure_cleanup_flag_name]

    # expect only 'true' values
    return !cleanup_value.nil? && cleanup_value.to_s == 'true'
  end
end
